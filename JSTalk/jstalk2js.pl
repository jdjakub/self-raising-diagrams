#!/usr/bin/env perl
# Generated by Claude Opus 4.5.
# Invoke as follows:
# perl jstalk2js.pl < jstalk-test.jstalk.js > jstalk-test.js
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';

# Transpile Smalltalk-style message syntax to JS send() calls
# ⟦obj myMessage: arg1 with: arg2 and: arg3⟧
# becomes: send(obj, 'myMessage:', arg1, 'with:', arg2, 'and:', arg3)

my $OPEN = '⟦';
my $CLOSE = '⟧';

sub find_matching_bracket {
    my ($str, $start) = @_;
    my $depth = 1;
    my $pos = $start;
    my $len = length($str);
    
    while ($pos < $len && $depth > 0) {
        my $ch = substr($str, $pos, 1);
        if ($ch eq $OPEN) {
            $depth++;
        } elsif ($ch eq $CLOSE) {
            $depth--;
        }
        $pos++ if $depth > 0;
    }
    return $depth == 0 ? $pos : -1;
}

sub find_matching {
    my ($str, $start, $open, $close) = @_;
    my $depth = 1;
    my $pos = $start;
    my $len = length($str);
    
    while ($pos < $len && $depth > 0) {
        my $ch = substr($str, $pos, 1);
        if ($ch eq $open) {
            $depth++;
        } elsif ($ch eq $close) {
            $depth--;
        }
        $pos++ if $depth > 0;
    }
    return $depth == 0 ? $pos : -1;
}

sub skip_balanced {
    # Skip over balanced brackets, parens, braces, strings, etc.
    my ($str, $pos) = @_;
    my $len = length($str);
    my $ch = substr($str, $pos, 1);
    
    if ($ch eq $OPEN) {
        return find_matching_bracket($str, $pos + 1);
    } elsif ($ch eq '[') {
        return find_matching($str, $pos + 1, '[', ']');
    } elsif ($ch eq '(') {
        return find_matching($str, $pos + 1, '(', ')');
    } elsif ($ch eq '{') {
        return find_matching($str, $pos + 1, '{', '}');
    } elsif ($ch eq '"' || $ch eq "'" || $ch eq '`') {
        # Simple string handling (doesn't handle escapes perfectly)
        my $quote = $ch;
        $pos++;
        while ($pos < $len) {
            my $c = substr($str, $pos, 1);
            if ($c eq '\\') {
                $pos += 2;
            } elsif ($c eq $quote) {
                return $pos;
            } else {
                $pos++;
            }
        }
        return $pos - 1;
    }
    return $pos;
}

sub tokenize_message {
    my ($content) = @_;
    
    $content =~ s/^\s+|\s+$//g;
    
    my @tokens;
    my $pos = 0;
    my $len = length($content);
    my $current = '';
    
    while ($pos < $len) {
        my $ch = substr($content, $pos, 1);
        
        if ($ch eq $OPEN || $ch eq '[' || $ch eq '(' || $ch eq '{' || $ch eq '"' || $ch eq "'" || $ch eq '`') {
            my $end = skip_balanced($content, $pos);
            $current .= substr($content, $pos, $end - $pos + 1);
            $pos = $end + 1;
        } elsif ($ch =~ /\s/) {
            if ($current ne '') {
                push @tokens, $current;
                $current = '';
            }
            $pos++;
        } elsif ($ch eq ':') {
            # Check if this is part of ternary ?: or object literal
            # Heuristic: if current token looks like an identifier, it's a keyword
            if ($current ne '' && $current =~ /^[a-zA-Z_][a-zA-Z0-9_]*$/) {
                $current .= ':';
                push @tokens, $current;
                $current = '';
            } else {
                $current .= ':';
            }
            $pos++;
        } else {
            $current .= $ch;
            $pos++;
        }
    }
    push @tokens, $current if $current ne '';
    
    return @tokens;
}

sub has_top_level_comma {
    my ($str) = @_;
    my $pos = 0;
    my $len = length($str);
    
    while ($pos < $len) {
        my $ch = substr($str, $pos, 1);
        if ($ch eq ',') {
            return 1;
        } elsif ($ch eq $OPEN || $ch eq '[' || $ch eq '(' || $ch eq '{' || $ch eq '"' || $ch eq "'" || $ch eq '`') {
            $pos = skip_balanced($str, $pos) + 1;
        } else {
            $pos++;
        }
    }
    return 0;
}

sub parse_message_send {
    my ($content) = @_;
    
    # Top-level comma means array literal, not message send
    return undef if has_top_level_comma($content);
    
    my @tokens = tokenize_message($content);
    
    return undef if @tokens == 0;
    
    my $receiver = shift @tokens;
    
    return undef if @tokens == 0;
    
    # Unary message: exactly one token that's an identifier without colon
    if (@tokens == 1 && $tokens[0] =~ /^[a-zA-Z_][a-zA-Z0-9_]*$/) {
        return [$receiver, "'$tokens[0]'"];
    }
    
    return undef unless $tokens[0] =~ /^[a-zA-Z_][a-zA-Z0-9_]*:$/;
    
    my @parts = ($receiver);
    
    while (@tokens) {
        my $tok = shift @tokens;
        if ($tok =~ /^[a-zA-Z_][a-zA-Z0-9_]*:$/) {
            push @parts, "'$tok'";
            if (@tokens) {
                push @parts, shift @tokens;
            }
        } else {
            if (@parts > 0) {
                $parts[-1] .= ' ' . $tok;
            }
        }
    }
    
    return \@parts;
}

sub transpile {
    my ($input) = @_;
    my $output = '';
    my $pos = 0;
    my $len = length($input);
    
    while ($pos < $len) {
        my $ch = substr($input, $pos, 1);
        
        if ($ch eq $OPEN) {
            my $end = find_matching_bracket($input, $pos + 1);
            if ($end == -1) {
                $output .= $ch;
                $pos++;
            } else {
                my $content = substr($input, $pos + 1, $end - $pos - 1);
                # Recursively transpile nested content first
                my $transpiled = transpile($content);
                # Try to parse as message send
                my $parts = parse_message_send($transpiled);
                if (defined $parts) {
                    $output .= 'send(' . join(', ', @$parts) . ')';
                } else {
                    # Not a message send, preserve brackets
                    $output .= $OPEN . $transpiled . $CLOSE;
                }
                $pos = $end + 1;
            }
        } else {
            $output .= $ch;
            $pos++;
        }
    }
    
    return $output;
}

my $input = do { local $/; <STDIN> };
print transpile($input);
