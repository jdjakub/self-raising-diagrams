ISSUES / ARCHITECTURE / PHILOSOPHY

Currently, the shape node (rect, circle, etc) gets the id, not its parent <g>.
Same goes for most annotations, e.g. 'containedIn'. The problem is:
- Conceptually, we want a shape containment tree in the DOM: e.g. a rect contains a circle.
- But in SVG, the visual shape element is a terminal DOM node. It gets wrapped inside
  a <g> and we add children to THAT.
So we need to decide whether the "local root" <g> or the "visual elem" shall represent the
conceptual shape.

I.e. where do all the annotations (id, classes, data-) go? On the <g>, or on the shape?

If on the <g>:
- Dispatch messages on receiver tag is now meaningless. Must dispatch on "current
tree shape" or "current emergent class" combining details from the entire subtree
- Many annoying problems go away
- In order to set shape props (e.g. fill, width), need to go to firstChild

If on the shape:
- Can continue to dispatch on receiver tag.

Probably gonna go with "on the <g>"

E.g. vtables can be registered for firstChild tag, css classes, etc

Problem: initially, all connectors and shapes are <path>s. Can distinguish by
presence of final Z (close shape) cmd. Do all containment testing on the geometry
first, as polygons? Or do containment testing afterwards?

Of course, there IS an algorithm in either order. If all are paths, we can do
generic slow path-path containment. If some shapes are specialised, we can do
double-dispatch with specialised methods.

Need to enumerate all type of shapes to test.

Would like for it all to be lazy. I need to test whether node A spatially contains
node B. Therefore, perform all prerequisite passes on relevant nodes (parse on demand).

Also, all DOM nodes need a smart JS obj derivable from them.

Let us adopt the following hierarchy. All shapes are Paths. If closed (Z), then it's a
Shape. Otherwise, it's a Connector. Closed shapes can be further specialised based on
constraints, but mutations that violate the constraints will degrade the class upwards.

Oops - we also have Text! Treatable as a Rect, maybe

OK: instead, we must first REIFY the implicit SVG semantics encoded in the browser's C++.
|-- can be traversed via the 'specialize' message (general-containment.js)
|== just seems like a subclass relationship

[any]
|== [DOM Text Node]
|== g
|== text
|== path
    |-- circle
    |-- polyline (+not curved)
        |-- polygon (+closed)
            |-- rect

0D point is a degen 1D open path is a degen 2D closed path (area).

There seem to be a few core semantics that are reasonable to expect across ALL diagrams:
- Exploit the DOM tree for containment relationships.
- Open paths connect closed areas. (what about connecting 1Ds occasionally??)
- Text labels attach to the closest 1D or 2D shape, for some definition of "closest".

Uh - we also have "fat arrows". Generally, any shape can be parsed as a connector:
just determine the two endpoints.

Problem: ids are the main text-compatible way of doing references in the SVG DOM. They show
up in singular attributes like data-origin and set attributes like "contains". If one wants to
rename an ID, all reference sites will have to be updated. Will need some way to enumerate
sites mentioning a particular ID.

Two-way references:
- if x label = y, y labelOf = x.
- if x contains ∋ y, y containedIn = x
- if x connections ∋ y, y connectors ∋ x
- if x origin = y, y originOf ∋ x
- if x target = y, y targetOf ∋ x

Want to delay red-box code execution to after all processing has been applied. Or else provide
hook points etc.

Magic red connector connects to anything on one end, and ONLY a magic red box on the other end.

When attaching connectors to shapes, it should be "point in shape OR point close enough to border"

------

DOMMeta (Like OMeta but in the DOM tree)
Inspiration: see my OMeta notes at
https://programmingmadecomplicated.wordpress.com/2025/11/24/notes-on-chains-of-meaning-in-steps/

---
path d=( M lx,ty L rx,ty L rx,by L lx,by Z ) ⟹ {
  return { type: 'rect', topLeft: [lx,ty], dims: [rx-lx, by-ty] }
}
---

path
All tag names have a tag matcher. Succeeds if curr DOM elem has that tag. Value is elem.

d=(...)
All attribute names have attribute matchers. Succeeds if curr DOM elem has that attr
and its value matches the value-matcher on its RHS.

M m L l Z etc
Only available in the scope of a d attr value matcher. Sequentially match path data cmds.
Embedded names are unified, wildcards permitted (`_`). Coordinates named via `,`, but will
match spaces or other seps in the string (as per the DOM spec for this stuff). Can also name
the pair e.g. `M p`. Can mix and match: e.g. `C p1 _ x3,_`. Can omit point e.g. `L L L` =
`L _ L _ L _`.

⟹ {} JS output expr.

---
g class=("arrow-line") {
  path d=(path:p),
  g transform=(matrix:m)
} ⟹ { points: p, ??? }
---

"arrow-line"
Succeeds if curr attr val is exactly that string. (TODO: embed OMeta text parsing DSL!)

{ ..., ..., ... }
Children matcher. Succeeds if curr DOM elem's children distinctly match each clause, in any
order (use embedded predicate to enforce ordering constraints). E.g. here there must be at least
2 children, a <path> and a <g>.

path
Within a d attr val matcher, means something different to the tag! Match any valid path cmd seq.

:p
...and call it p.

matrix
Similarly, within a transform attr, match the overall matrix.

-----------

Those are all DOM->JS. Here's a DOM->DOM mutation expr:

FOR ALL matchElt(i) (
  tag = 'path' ⟹ 'rect'
  class ⊇ { 'real', 'connection' }
  d = "M lx,ty L rx,ty L rx,by L lx,by Z"
  let [x, y, w, h] = [lx, ty, rx - lx, by - ty]
  attributes {
    x ⟹ x, y ⟹ y, width ⟹ w, height ⟹ h, d ⇏
  }
  id ⟹ 'r'+(i+1)
)

All of the "reading/matching" things are confirmed first. If all succeed, the
mutation ⟹ operators activate.

- Ensure tag is 'path'
- And class contains 'real' and 'connection'
- And the d attr matches the path template (binding some vars)
- And with some more vars bound...
- Oh, that's it.

If all good, then:

- Change tag to 'rect'
- Set the attrs, delete the d attr
- Set the id based on the match index

---

PATH TEMPLATE LANGUAGE

cmd = 'M point:p? ->{ moveAbs(p) }
    | 'm point:p? ->{ moveRel(p) }
    | 'L' point:p? ->{ lineAbs(p) }
    | 'l' point:p? ->{ lineRel(p) }
    | 'Q (point:p1 point:p2)? ->{ quadAbs(p1, p2) }
    | 'q (point:p1 point:p2)? ->{ quadRel(p1, p2) }
    | 'C (point:p1 point:p2 point:p3)? ->{ cubicAbs(p1, p2, p3) }
    | 'c (point:p1 point:p2 point:p3)? ->{ cubicRel(p1, p2, p3) }
    | ('Z | 'z) ->{ closeShape() }

point = wildcard | coord ', coord
coord = wildcard | variable | constant

PATH PARSING

cmd = 
