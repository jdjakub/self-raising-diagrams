ISSUES / ARCHITECTURE / PHILOSOPHY

Currently, the shape node (rect, circle, etc) gets the id, not its parent <g>.
Same goes for most annotations, e.g. 'containedIn'. The problem is:
- Conceptually, we want a shape containment tree in the DOM: e.g. a rect contains a circle.
- But in SVG, the visual shape element is a terminal DOM node. It gets wrapped inside
  a <g> and we add children to THAT.
So we need to decide whether the "local root" <g> or the "visual elem" shall represent the
conceptual shape.

Containment / geometry stuff ONLY works with rects and arrows. Should work out
containment for ALL shapes. And incidence of endpoints for connectors.

Paths/arrows are followed in path coords order, irrespective of arrowheads.

Problem: initially, all connectors and shapes are <path>s. Can distinguish by
presence of final Z (close shape) cmd. Do all containment testing on the geometry
first, as polygons? Or do containment testing afterwards?

Of course, there IS an algorithm in either order. If all are paths, we can do
generic slow path-path containment. If some shapes are specialised, we can do
double-dispatch with specialised methods.

Need to enumerate all type of shapes to test.

Would like for it all to be lazy. I need to test whether node A spatially contains
node B. Therefore, perform all prerequisite passes on relevant nodes (parse on demand).

Also, all DOM nodes need a smart JS obj derivable from them.

Let us adopt the following hierarchy. All shapes are Paths. If closed (Z), then it's a
Shape. Otherwise, it's a Connector. Closed shapes can be further specialised based on
constraints, but mutations that violate the constraints will degrade the class upwards.

Oops - we also have Text! Treatable as a Rect, maybe

OK: instead, we must first REIFY the implicit SVG semantics encoded in the browser's C++.
|-- can be traversed via the 'specialize' message (general-containment.js)
|== just seems like a subclass relationship

[any]
|== [DOM Text Node]
|== g
|== text
|== path
    |-- circle
    |-- polyline (+not curved)
        |-- polygon (+closed)
            |-- rect

------

DOMMeta (Like OMeta but in the DOM tree)
Inspiration: see my OMeta notes at
https://programmingmadecomplicated.wordpress.com/2025/11/24/notes-on-chains-of-meaning-in-steps/

---
path d=( M lx,ty L rx,ty L rx,by L lx,by Z ) ⟹ {
  return { type: 'rect', topLeft: [lx,ty], dims: [rx-lx, by-ty] }
}
---

path
All tag names have a tag matcher. Succeeds if curr DOM elem has that tag. Value is elem.

d=(...)
All attribute names have attribute matchers. Succeeds if curr DOM elem has that attr
and its value matches the value-matcher on its RHS.

M m L l Z etc
Only available in the scope of a d attr value matcher. Sequentially match path data cmds.
Embedded names are unified, wildcards permitted (`_`). Coordinates named via `,`, but will
match spaces or other seps in the string (as per the DOM spec for this stuff). Can also name
the pair e.g. `M p`. Can mix and match: e.g. `C p1 _ x3,_`. Can omit point e.g. `L L L` =
`L _ L _ L _`.

⟹ {} JS output expr.

---
g class=("arrow-line") {
  path d=(path:p),
  g transform=(matrix:m)
} ⟹ { points: p, ??? }
---

"arrow-line"
Succeeds if curr attr val is exactly that string. (TODO: embed OMeta text parsing DSL!)

{ ..., ..., ... }
Children matcher. Succeeds if curr DOM elem's children distinctly match each clause, in any
order (use embedded predicate to enforce ordering constraints). E.g. here there must be at least
2 children, a <path> and a <g>.

path
Within a d attr val matcher, means something different to the tag! Match any valid path cmd seq.

:p
...and call it p.

matrix
Similarly, within a transform attr, match the overall matrix.

-----------

Those are all DOM->JS. Here's a DOM->DOM mutation expr:

FOR ALL matchElt(i) (
  tag = 'path' ⟹ 'rect'
  class ⊇ { 'real', 'connection' }
  d = "M lx,ty L rx,ty L rx,by L lx,by Z"
  let [x, y, w, h] = [lx, ty, rx - lx, by - ty]
  attributes {
    x ⟹ x, y ⟹ y, width ⟹ w, height ⟹ h, d ⇏
  }
  id ⟹ 'r'+(i+1)
)

All of the "reading/matching" things are confirmed first. If all succeed, the
mutation ⟹ operators activate.

- Ensure tag is 'path'
- And class contains 'real' and 'connection'
- And the d attr matches the path template (binding some vars)
- And with some more vars bound...
- Oh, that's it.

If all good, then:

- Change tag to 'rect'
- Set the attrs, delete the d attr
- Set the id based on the match index

---

PATH TEMPLATE LANGUAGE

cmd = 'M point:p? ->{ moveAbs(p) }
    | 'm point:p? ->{ moveRel(p) }
    | 'L' point:p? ->{ lineAbs(p) }
    | 'l' point:p? ->{ lineRel(p) }
    | 'Q (point:p1 point:p2)? ->{ quadAbs(p1, p2) }
    | 'q (point:p1 point:p2)? ->{ quadRel(p1, p2) }
    | 'C (point:p1 point:p2 point:p3)? ->{ cubicAbs(p1, p2, p3) }
    | 'c (point:p1 point:p2 point:p3)? ->{ cubicRel(p1, p2, p3) }
    | ('Z | 'z) ->{ closeShape() }

point = wildcard | coord ', coord
coord = wildcard | variable | constant

PATH PARSING

cmd = 
